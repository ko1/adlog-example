name: aggregate-logs

on:
  workflow_run:
    workflows:
      - sample-one
      - sample-two
      - sample-three
    types:
      - completed

permissions:
  actions: read
  contents: read

jobs:
  aggregate:
    runs-on: ubuntu-latest
    steps:
      - name: Fetch logs from sample workflows
        env:
          GH_TOKEN: ${{ secrets.ADLOGS_GH_TOKEN }}
          GITHUB_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          set -euo pipefail
          if [ -z "${GH_TOKEN:-}" ]; then
            GH_TOKEN="${GITHUB_TOKEN}"
          fi
          export GH_TOKEN
          echo "GH token present: ${GH_TOKEN:+yes}"
          gh api "repos/${REPO}" --jq '.full_name' || echo "Repo check failed"
          gh api "repos/${REPO}/actions/runs" --jq '.total_count' || echo "Runs list failed"
          workflow_names=("sample-one" "sample-two" "sample-three")
          mkdir -p logs
          fetch_runs() {
            gh api "repos/${REPO}/actions/runs" -f per_page=100
          }

          wait_for_run() {
            local wf_name="$1"
            local attempts=8
            local delay=5
            for i in $(seq 1 "${attempts}"); do
              runs_json=$(fetch_runs)
              if [ -z "${runs_json}" ] || [ "${runs_json}" = "null" ]; then
                echo "Runs list unavailable (${i}/${attempts})" >&2
                sleep "${delay}"
                continue
              fi
              run_id=$(echo "${runs_json}" | jq -r ".workflow_runs[] | select(.name == \"${wf_name}\" and .status == \"completed\" and .head_sha == \"${SHA}\") | .id" | head -n 1)
              if [ -n "${run_id}" ] && [ "${run_id}" != "null" ]; then
                echo "${run_id}"
                return 0
              fi
              status=$(echo "${runs_json}" | jq -r ".workflow_runs[] | select(.name == \"${wf_name}\" and .head_sha == \"${SHA}\") | .status" | head -n 1)
              echo "Waiting for ${wf_name} to complete (${i}/${attempts}); status=${status:-unknown}" >&2
              sleep "${delay}"
            done
            return 1
          }

          download_logs() {
            local run_id="$1"
            local out_file="$2"
            local attempts=10
            local delay=6
            for i in $(seq 1 "${attempts}"); do
              if gh run view "${run_id}" --repo "${REPO}" --log > "${out_file}"; then
                return 0
              fi
              echo "Logs not ready (attempt ${i}/${attempts}), retrying in ${delay}s..."
              sleep "${delay}"
            done
            return 1
          }

          for wf_name in "${workflow_names[@]}"; do
            run_id=$(wait_for_run "${wf_name}") || true
            if [ -z "${run_id}" ]; then
              echo "No completed run found for ${wf_name}"
              continue
            fi
            echo "Downloading logs for ${wf_name} (run ${run_id})"
            gh api "repos/${REPO}/actions/runs/${run_id}" --jq '.id' || echo "Run lookup failed for ${run_id}"
            if ! download_logs "${run_id}" "logs/${wf_name}.log"; then
              echo "Failed to download logs for ${wf_name}"
              continue
            fi
            echo "---- ${wf_name} logs ----"
            cat "logs/${wf_name}.log"
            echo "--------------------"
          done
